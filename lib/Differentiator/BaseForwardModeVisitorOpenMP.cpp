#include "clad/Differentiator/BaseForwardModeVisitor.h"

using namespace clang;
using namespace llvm::omp;

namespace clad {
clang::OMPClause* BaseForwardModeVisitor::VisitOMPReductionClause(
    const clang::OMPReductionClause* C) {
  llvm::SmallVector<Expr*, 16> Vars;
  Vars.reserve(C->varlist_size());
#if CLANG_VERSION_MAJOR < 20
  for (const auto* Var : C->varlists())
#else
  for (const auto* Var : C->varlist())
#endif
  {
    Vars.push_back(Visit(Var).getExpr_dx());
    Vars.push_back(Clone(Var));
  }
  CXXScopeSpec ReductionIdScopeSpec;
  ReductionIdScopeSpec.Adopt(C->getQualifierLoc());
  DeclarationNameInfo NameInfo = C->getNameInfo();
  return CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema).ActOnOpenMPReductionClause(
      Vars, CLAD_COMPAT_CLANG21_getModifier(C), C->getBeginLoc(),
      C->getLParenLoc(), C->getModifierLoc(), C->getColonLoc(), C->getEndLoc(),
      ReductionIdScopeSpec, NameInfo);
}

OMPClause* BaseForwardModeVisitor::VisitOMPClause(const OMPClause* S) {
  if (!S)
    return nullptr;

  switch (S->getClauseKind()) {
  case OMPC_reduction:
    return VisitOMPReductionClause(cast<OMPReductionClause>(S));
  default:
    llvm_unreachable("Clause is not supported.");
  }
}

StmtDiff BaseForwardModeVisitor::VisitOMPExecutableDirective(
    const clang::OMPExecutableDirective* D) {
  // Transform the clauses
  llvm::SmallVector<OMPClause*, 16> TClauses;
  ArrayRef<OMPClause*> Clauses = D->clauses();
  TClauses.reserve(Clauses.size());
  for (auto* I : Clauses) {
    if (I) {
      CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema).StartOpenMPClause(
          I->getClauseKind());
      OMPClause* Clause = VisitOMPClause(I);
      CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema).EndOpenMPClause();
      if (Clause)
        TClauses.push_back(Clause);
    } else {
      TClauses.push_back(nullptr);
    }
  }
  StmtDiff AssociatedStmt;
  if (D->hasAssociatedStmt() && D->getAssociatedStmt()) {
    CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema).ActOnOpenMPRegionStart(
        D->getDirectiveKind(), getCurrentScope());
    StmtDiff Body;
    {
      Sema::CompoundScopeRAII CompoundScope(m_Sema);
      const auto* CS = D->getInnermostCapturedStmt()->getCapturedStmt();
      Body = Visit(CS);
      if (isOpenMPLoopDirective(D->getDirectiveKind())) {
        // FIXME: Ignore the differential variable generated by loop variables
        // to obtain a standard ForStmt.
        for (auto* SubStmt : Body.getStmt()->children()) {
          if (isa<ForStmt>(SubStmt)) {
            Body = SubStmt;
            break;
          }
        }
        Body = CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema)
                   .ActOnOpenMPCanonicalLoop(Body.getStmt())
                   .get();
      }
    }
    AssociatedStmt = CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema)
                         .ActOnOpenMPRegionEnd(Body.getStmt(), TClauses)
                         .get();
  }
  // Transform directive name for 'omp critical' directive.
  DeclarationNameInfo DirName;
  // if (D->getDirectiveKind() == OMPD_critical) {
  //   DirName = cast<OMPCriticalDirective>(D)->getDirectiveName();
  //   DirName = getDerived().TransformDeclarationNameInfo(DirName);
  // }
  OpenMPDirectiveKind CancelRegion = OMPD_unknown;
  if (D->getDirectiveKind() == OMPD_cancellation_point)
    CancelRegion = cast<OMPCancellationPointDirective>(D)->getCancelRegion();
  else if (D->getDirectiveKind() == OMPD_cancel)
    CancelRegion = cast<OMPCancelDirective>(D)->getCancelRegion();

  return CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema)
      .ActOnOpenMPExecutableDirective(
          D->getDirectiveKind(), DirName, CancelRegion, TClauses,
          AssociatedStmt.getStmt(), D->getBeginLoc(), D->getEndLoc())
      .get();
}

StmtDiff BaseForwardModeVisitor::VisitOMPParallelForDirective(
    const clang::OMPParallelForDirective* D) {
  DeclarationNameInfo DirName;
  CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema).StartOpenMPDSABlock(
      llvm::omp::OMPD_parallel_for, DirName, nullptr, D->getBeginLoc());
  StmtDiff Res = VisitOMPExecutableDirective(D);
  CLAD_COMPAT_CLANG19_SemaOpenMP(m_Sema).EndOpenMPDSABlock(Res.getStmt());
  return Res;
}
} // namespace clad